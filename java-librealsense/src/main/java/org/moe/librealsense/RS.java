/*
Copyright 2014-2016 Intel Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package org.moe.librealsense;

import org.moe.natj.cxx.CxxObject;
import org.moe.natj.cxx.CxxOperatorKind;
import org.moe.natj.cxx.ann.*;
import org.moe.natj.general.ptr.*;

@CxxHeader(value = "rs.hpp", useQuotes = true)
public class RS {
    private RS() {
    }

    public enum stream {
        /**
         * Native stream of depth data produced by RealSense device
         */
        depth(0),
        /**
         * Native stream of color data captured by RealSense device
         */
        color(1),
        /**
         * Native stream of infrared data captured by RealSense device
         */
        infrared(2),
        /**
         * Native stream of infrared data captured from a second viewpoint by RealSense device
         */
        infrared2(3),
        /**
         * Synthetic stream containing point cloud data generated by deprojecting the depth image
         */
        points(4),
        /**
         * Synthetic stream containing undistorted color data with no extrinsic rotation from the depth stream
         */
        rectified_color(5),
        /**
         * Synthetic stream containing color data but sharing intrinsics of depth stream
         */
        color_aligned_to_depth(6),
        /**
         * Synthetic stream containing second viewpoint infrared data but sharing intrinsics of depth stream
         */
        infrared2_aligned_to_depth(7),
        /**
         * Synthetic stream containing depth data but sharing intrinsics of color stream
         */
        depth_aligned_to_color(8),
        /**
         * Synthetic stream containing depth data but sharing intrinsics of rectified color stream
         */
        depth_aligned_to_rectified_color(9),
        /**
         * Synthetic stream containing depth data but sharing intrinsics of second viewpoint infrared stream
         */
        depth_aligned_to_infrared2(10),
        //
        ;

        public final int value;

        stream(int value) {
            this.value = value;
        }
    }

    public enum format {
        /**
         * any
         */
        any(0),
        /**
         * 16 bit linear depth values. The depth is meters is equal to depth scale * pixel value
         */
        z16(1),
        /**
         * 16 bit linear disparity values. The depth in meters is equal to depth scale / pixel value
         */
        disparity16(2),
        /**
         * 32 bit floating point 3D coordinates.
         */
        xyz32f(3),
        /**
         * yuyv
         */
        yuyv(4),
        /**
         * rgb8
         */
        rgb8(5),
        /**
         * bgr8
         */
        bgr8(6),
        /**
         * rgba8
         */
        rgba8(7),
        /**
         * bgra8
         */
        bgra8(8),
        /**
         * y8
         */
        y8(9),
        /**
         * y16
         */
        y16(10),
        /**
         * Four 10-bit luminance values encoded into a 5-byte macropixel
         */
        raw10(11),
        //
        ;

        public final int value;

        format(int value) {
            this.value = value;
        }
    }

    public enum preset {
        /**
         * best_quality
         */
        best_quality(0),
        /**
         * largest_image
         */
        largest_image(1),
        /**
         * highest_framerate
         */
        highest_framerate(2),
        //
        ;

        public final int value;

        preset(int value) {
            this.value = value;
        }
    }

    public enum distortion {
        /**
         * Rectilinear images, no distortion compensation required
         */
        none(0),
        /**
         * Equivalent to Brown-Conrady distortion, except that tangential distortion is applied to radially distorted points
         */
        modified_brown_conrady(1),
        /**
         * Equivalent to Brown-Conrady distortion, except undistorts image instead of distorting it
         */
        inverse_brown_conrady(2),
        //
        ;

        public final int value;

        distortion(int value) {
            this.value = value;
        }
    }

    public enum option {
        /**
         * color_backlight_compensation
         */
        color_backlight_compensation(0),
        /**
         * color_brightness
         */
        color_brightness(1),
        /**
         * color_contrast
         */
        color_contrast(2),
        /**
         * Controls exposure time of color camera. Setting any value will disable auto exposure.
         */
        color_exposure(3),
        /**
         * color_gain
         */
        color_gain(4),
        /**
         * color_gamma
         */
        color_gamma(5),
        /**
         * color_hue
         */
        color_hue(6),
        /**
         * color_saturation
         */
        color_saturation(7),
        /**
         * color_sharpness
         */
        color_sharpness(8),
        /**
         * Controls white balance of color image. Setting any value will disable auto white balance.
         */
        color_white_balance(9),
        /**
         * Set to 1 to enable automatic exposure control, or 0 to return to manual control
         */
        color_enable_auto_exposure(10),
        /**
         * Set to 1 to enable automatic white balance control, or 0 to return to manual control
         */
        color_enable_auto_white_balance(11),
        /**
         * 0 - 15
         */
        f200_laser_power(12),
        /**
         * 0 - 3
         */
        f200_accuracy(13),
        /**
         * 0 - 100
         */
        f200_motion_range(14),
        /**
         * 0 - 7
         */
        f200_filter_option(15),
        /**
         * 0 - 15
         */
        f200_confidence_threshold(16),
        /**
         * {2, 5, 15, 30, 60}
         */
        sr300_dynamic_fps(17),
        /**
         * sr300_auto_range_enable_motion_versus_range
         */
        sr300_auto_range_enable_motion_versus_range(18),
        /**
         * sr300_auto_range_enable_laser
         */
        sr300_auto_range_enable_laser(19),
        /**
         * sr300_auto_range_min_motion_versus_range
         */
        sr300_auto_range_min_motion_versus_range(20),
        /**
         * sr300_auto_range_max_motion_versus_range
         */
        sr300_auto_range_max_motion_versus_range(21),
        /**
         * sr300_auto_range_start_motion_versus_range
         */
        sr300_auto_range_start_motion_versus_range(22),
        /**
         * sr300_auto_range_min_laser
         */
        sr300_auto_range_min_laser(23),
        /**
         * sr300_auto_range_max_laser
         */
        sr300_auto_range_max_laser(24),
        /**
         * sr300_auto_range_start_laser
         */
        sr300_auto_range_start_laser(25),
        /**
         * sr300_auto_range_upper_threshold
         */
        sr300_auto_range_upper_threshold(26),
        /**
         * sr300_auto_range_lower_threshold
         */
        sr300_auto_range_lower_threshold(27),
        /**
         * {0, 1}
         */
        r200_lr_auto_exposure_enabled(28),
        /**
         * 100 - 1600 (Units of 0.01)
         */
        r200_lr_gain(29),
        /**
         * > 0 (Units of 0.1 ms)
         */
        r200_lr_exposure(30),
        /**
         * {0, 1}
         */
        r200_emitter_enabled(31),
        /**
         * micrometers per increment in integer depth values, 1000 is default (mm scale)
         */
        r200_depth_units(32),
        /**
         * 0 - USHORT_MAX
         */
        r200_depth_clamp_min(33),
        /**
         * 0 - USHORT_MAX
         */
        r200_depth_clamp_max(34),
        /**
         * 0 - 1000, the increments in integer disparity values corresponding to one pixel of disparity
         */
        r200_disparity_multiplier(35),
        /**
         * r200_disparity_shift
         */
        r200_disparity_shift(36),
        /**
         * r200_auto_exposure_mean_intensity_set_point
         */
        r200_auto_exposure_mean_intensity_set_point(37),
        /**
         * r200_auto_exposure_bright_ratio_set_point
         */
        r200_auto_exposure_bright_ratio_set_point(38),
        /**
         * r200_auto_exposure_kp_gain
         */
        r200_auto_exposure_kp_gain(39),
        /**
         * r200_auto_exposure_kp_exposure
         */
        r200_auto_exposure_kp_exposure(40),
        /**
         * r200_auto_exposure_kp_dark_threshold
         */
        r200_auto_exposure_kp_dark_threshold(41),
        /**
         * r200_auto_exposure_top_edge
         */
        r200_auto_exposure_top_edge(42),
        /**
         * r200_auto_exposure_bottom_edge
         */
        r200_auto_exposure_bottom_edge(43),
        /**
         * r200_auto_exposure_left_edge
         */
        r200_auto_exposure_left_edge(44),
        /**
         * r200_auto_exposure_right_edge
         */
        r200_auto_exposure_right_edge(45),
        /**
         * r200_depth_control_estimate_median_decrement
         */
        r200_depth_control_estimate_median_decrement(46),
        /**
         * r200_depth_control_estimate_median_increment
         */
        r200_depth_control_estimate_median_increment(47),
        /**
         * r200_depth_control_median_threshold
         */
        r200_depth_control_median_threshold(48),
        /**
         * r200_depth_control_score_minimum_threshold
         */
        r200_depth_control_score_minimum_threshold(49),
        /**
         * r200_depth_control_score_maximum_threshold
         */
        r200_depth_control_score_maximum_threshold(50),
        /**
         * r200_depth_control_texture_count_threshold
         */
        r200_depth_control_texture_count_threshold(51),
        /**
         * r200_depth_control_texture_difference_threshold
         */
        r200_depth_control_texture_difference_threshold(52),
        /**
         * r200_depth_control_second_peak_threshold
         */
        r200_depth_control_second_peak_threshold(53),
        /**
         * r200_depth_control_neighbor_threshold
         */
        r200_depth_control_neighbor_threshold(54),
        /**
         * r200_depth_control_lr_threshold
         */
        r200_depth_control_lr_threshold(55),
        //
        ;

        public final int value;

        option(int value) {
            this.value = value;
        }
    }

    @CxxClass("rs::float2")
    public interface float2 extends CxxObject {
        @CxxFieldGetter("x")
        float getX();

        @CxxFieldSetter("x")
        void setX(float x);

        @CxxFieldGetter("y")
        float getY();

        @CxxFieldSetter("y")
        void setY(float y);
    }

    @CxxClass("rs::float3")
    public interface float3 extends CxxObject {
        @CxxFieldGetter("x")
        float getX();

        @CxxFieldSetter("x")
        void setX(float x);

        @CxxFieldGetter("y")
        float getY();

        @CxxFieldSetter("y")
        void setY(float y);

        @CxxFieldGetter("z")
        float getZ();

        @CxxFieldSetter("z")
        void setZ(float z);
    }

    @CxxClass("rs_intrinsics")
    public interface rs_intrinsics extends CxxObject {
        /**
         * width of the image in pixels
         */
        @CxxFieldGetter("width")
        int getWidth();

        /**
         * width of the image in pixels
         */
        @CxxFieldSetter("width")
        void setWidth(int width);

        /**
         * height of the image in pixels
         */
        @CxxFieldGetter("height")
        int getHeight();

        /**
         * height of the image in pixels
         */
        @CxxFieldSetter("height")
        void setHeight(int height);

        /**
         * horizontal coordinate of the principal point of the image, as a pixel offset from the left edge
         */
        @CxxFieldGetter("ppx")
        float getPpx();

        /**
         * horizontal coordinate of the principal point of the image, as a pixel offset from the left edge
         */
        @CxxFieldSetter("ppx")
        void setPpx(float ppx);

        /**
         * vertical coordinate of the principal point of the image, as a pixel offset from the top edge
         */
        @CxxFieldGetter("ppy")
        float getPpy();

        /**
         * vertical coordinate of the principal point of the image, as a pixel offset from the top edge
         */
        @CxxFieldSetter("ppy")
        void setPpy(float ppy);

        /**
         * focal length of the image plane, as a multiple of pixel width
         */
        @CxxFieldGetter("fx")
        float getFx();

        /**
         * focal length of the image plane, as a multiple of pixel width
         */
        @CxxFieldSetter("fx")
        void setFx(float fx);

        /**
         * focal length of the image plane, as a multiple of pixel height
         */
        @CxxFieldGetter("fy")
        float getFy();

        /**
         * focal length of the image plane, as a multiple of pixel height
         */
        @CxxFieldSetter("fy")
        void setFy(float fy);

        /**
         * distortion model of the image
         */
        @CxxFieldGetter("model")
        @CxxEnum("rs_distortion")
        int getModel();

        /**
         * distortion model of the image
         */
        @CxxFieldSetter("model")
        void setModel(@CxxEnum("rs_distortion") int model);

        /**
         * distortion coefficients (5 elements)
         */
        @CxxFieldGetter("coeffs")
        FloatPtr getCoeffs();
    }

    @CxxClass("rs::intrinsics")
    public interface intrinsics extends rs_intrinsics {
        @CxxMethod(isConst = true)
        float hfov();

        @CxxMethod(isConst = true)
        float vfov();

        @CxxMethod(isConst = true)
        @CxxEnum("rs::distortion")
        int /* distortion */  model();

        // Helpers for mapping between pixel coordinates and texture coordinates
        @CxxMethod(isConst = true)
        @CxxByValue
        float2 pixel_to_texcoord(@CxxConst @CxxByReference float2 pixel);

        @CxxMethod(isConst = true)
        @CxxByValue
        float2 texcoord_to_pixel(@CxxConst @CxxByReference float2 coord);

        // Helpers for mapping from image coordinates into 3D space
        @CxxMethod(isConst = true)
        @CxxByValue
        float3 deproject(@CxxConst @CxxByReference float2 pixel, float depth);

        @CxxMethod(isConst = true)
        @CxxByValue
        float3 deproject_from_texcoord(@CxxConst @CxxByReference float2 coord, float depth);

        // Helpers for mapping from 3D space into image coordinates
        @CxxMethod(isConst = true)
        @CxxByValue
        float2 project(@CxxConst @CxxByReference float3 point);

        @CxxMethod(isConst = true)
        @CxxByValue
        float2 project_to_texcoord(@CxxConst @CxxByReference float3 point);

        @CxxOperator(value = CxxOperatorKind.EQUAL, isConst = true)
        boolean equal(@CxxConst @CxxByReference intrinsics r);
    }

    @CxxClass("rs_extrinsics")
    public interface rs_extrinsics extends CxxObject {
        /**
         * column-major 3x3 rotation matrix (9 elements)
         */
        @CxxFieldGetter("rotation")
        FloatPtr getRotation();

        /**
         * 3 element translation vector, in meters (3 elements)
         */
        @CxxFieldGetter("translation")
        FloatPtr getTranslation();
    }

    @CxxClass("rs::extrinsics")
    public interface extrinsics extends rs_extrinsics {
        @CxxMethod(isConst = true)
        boolean is_identity();

        @CxxMethod(isConst = true)
        @CxxByValue
        float3 transform(@CxxConst @CxxByReference float3 point);
    }

    @CxxClass("rs::context")
    @CxxCopyConstructorUnavailable
    public interface context extends CxxObject {
        /// determine number of connected devices
        /// \return  the count of devices
        @CxxMethod(isConst = true)
        int get_device_count();

        /// retrieve connected device by index
        /// \param[in] index  the zero based index of device to retrieve
        /// \return           the requested device
        @CxxMethod
        device get_device(int index);
    }

    @CxxConstructor
    public static native context contextCreate();

    @CxxClass("rs::device")
    @CxxDefaultConstructorUnavailable
    @CxxCopyConstructorUnavailable
    @CxxDestructorUnavailable
    public interface device extends CxxObject {
        /// retrieve a human readable device model string
        /// \return  the model string, such as "Intel RealSense F200" or "Intel RealSense R200"
        @CxxMethod(isConst = true)
        ConstBytePtr get_name();

        /// retrieve the unique serial number of the device
        /// \return  the serial number, in a format specific to the device model
        @CxxMethod(isConst = true)
        ConstBytePtr get_serial();

        /// retrieve the version of the firmware currently installed on the device
        /// \return  firmware version string, in a format is specific to device model
        @CxxMethod(isConst = true)
        ConstBytePtr get_firmware_version();

        /// retrieve extrinsic transformation between the viewpoints of two different streams
        /// \param[in] from_stream  stream whose coordinate space we will transform from
        /// \param[in] to_stream    stream whose coordinate space we will transform to
        /// \return                 the transformation between the two streams
        @CxxMethod(isConst = true)
        @CxxByValue
        extrinsics get_extrinsics(@CxxEnum("rs::stream") int /* stream */ from_stream, @CxxEnum("rs::stream") int /* stream */ to_stream);

        /// retrieve mapping between the units of the depth image and meters
        /// \return  depth in meters corresponding to a depth value of 1
        @CxxMethod(isConst = true)
        float get_depth_scale();

        /// determine if the device allows a specific option to be queried and set
        /// \param[in] option  the option to check for support
        /// \return            true if the option can be queried and set
        @CxxMethod(isConst = true)
        boolean supports_option(@CxxEnum("rs::option") int /* option */ option);

        /// determine the number of streaming modes available for a given stream
        /// \param[in] stream  the stream whose modes will be enumerated
        /// \return            the count of available modes
        @CxxMethod(isConst = true)
        int get_stream_mode_count(@CxxEnum("rs::stream") int /* stream */ stream);

        /// determine the properties of a specific streaming mode
        /// \param[in] stream      the stream whose mode will be queried
        /// \param[in] index       the zero based index of the streaming mode
        /// \param[out] width      the width of a frame image in pixels
        /// \param[out] height     the height of a frame image in pixels
        /// \param[out] format     the pixel format of a frame image
        /// \param[out] framerate  the number of frames which will be streamed per second
        @CxxMethod(isConst = true)
        void get_stream_mode(@CxxEnum("rs::stream") int /* stream */ stream, int index, @CxxByReference IntPtr width,
                             @CxxByReference IntPtr height, @CxxByReference @CxxEnum("rs::format") IntPtr /* format& */ format,
                             @CxxByReference IntPtr framerate);

        /// enable a specific stream and request specific properties
        /// \param[in] stream     the stream to enable
        /// \param[in] width      the desired width of a frame image in pixels, or 0 if any width is acceptable
        /// \param[in] height     the desired height of a frame image in pixels, or 0 if any height is acceptable
        /// \param[in] format     the pixel format of a frame image, or ANY if any format is acceptable
        /// \param[in] framerate  the number of frames which will be streamed per second, or 0 if any framerate is acceptable
        @CxxMethod
        void enable_stream(@CxxEnum("rs::stream") int /* stream */ stream, int width, int height, @CxxEnum("rs::format") int /* format */ format, int framerate);

        /// enable a specific stream and request properties using a preset
        /// \param[in] stream  the stream to enable
        /// \param[in] preset  the preset to use to enable the stream
        @CxxMethod
        void enable_stream(@CxxEnum("rs::stream") int /* stream */ stream, @CxxEnum("rs::preset") int /* preset */ preset);

        /// disable a specific stream
        /// \param[in] stream  the stream to disable
        @CxxMethod
        void disable_stream(@CxxEnum("rs::stream") int /* stream */ stream);

        /// determine if a specific stream is enabled
        /// \param[in] stream  the stream to check
        /// \return            true if the stream is currently enabled
        @CxxMethod(isConst = true)
        boolean is_stream_enabled(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve the width in pixels of a specific stream, equivalent to the width field from the stream's intrinsics
        /// \param[in] stream  the stream whose width to retrieve
        /// \return            the width in pixels of images from this stream
        @CxxMethod(isConst = true)
        int get_stream_width(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve the height in pixels of a specific stream, equivalent to the height field from the stream's intrinsics
        /// \param[in] stream  the stream whose height to retrieve
        /// \return            the height in pixels of images from this stream
        @CxxMethod(isConst = true)
        int get_stream_height(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve the pixel format for a specific stream
        /// \param[in] stream  the stream whose format to retrieve
        /// \return            the pixel format of the stream
        @CxxMethod(isConst = true)
        @CxxEnum("rs::format")
        int /* format */ get_stream_format(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve the framerate for a specific stream
        /// \param[in] stream  the stream whose framerate to retrieve
        /// \return            the framerate of the stream, in frames per second
        @CxxMethod(isConst = true)
        int get_stream_framerate(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve intrinsic camera parameters for a specific stream
        /// \param[in] stream  the stream whose parameters to retrieve
        /// \return            the intrinsic parameters of the stream
        @CxxMethod(isConst = true)
        @CxxByValue
        intrinsics get_stream_intrinsics(@CxxEnum("rs::stream") int /* stream */ stream);

        /// begin streaming on all enabled streams for this device
        ///
        @CxxMethod
        void start();

        /// end streaming on all streams for this device
        ///
        @CxxMethod
        void stop();

        /// determine if the device is currently streaming
        /// \return  true if the device is currently streaming
        @CxxMethod(isConst = true)
        boolean is_streaming();

        /// retrieve the available range of values of a supported option
        /// \param[in] option  the option whose range should be queried
        /// \param[out] min    the minimum value which will be accepted for this option
        /// \param[out] max    the maximum value which will be accepted for this option
        /// \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values
        @CxxMethod
        void get_option_range(@CxxEnum("rs::option") int /* option */ option, @CxxByReference DoublePtr min,
                              @CxxByReference DoublePtr max, @CxxByReference DoublePtr step);

        /// efficiently retrieve the value of an arbitrary number of options, using minimal hardware IO
        /// \param[in] options  the array of options which should be queried
        /// \param[in] count    the length of the options and values arrays
        /// \param[out] values  the array which will receive the values of the queried options
        @CxxMethod
        void get_options(@CxxEnum("rs::option") ConstIntPtr /* const option * */ options, int count, DoublePtr values);

        /// efficiently set the value of an arbitrary number of options, using minimal hardware IO
        /// \param[in] options  the array of options which should be set
        /// \param[in] count    the length of the options and values arrays
        /// \param[in] values   the array of values to which the options should be set
        @CxxMethod
        void set_options(@CxxEnum("rs::option") ConstIntPtr /* const option * */ options, int count, ConstDoublePtr values);

        /// retrieve the current value of a single option
        /// \param[in] option  the option whose value should be retrieved
        /// \return            the value of the option
        @CxxMethod
        double get_option(@CxxEnum("rs::option") int /* option */ option);

        /// set the current value of a single option
        /// \param[in] option  the option whose value should be set
        /// \param[in] value   the value of the option
        @CxxMethod
        void set_option(@CxxEnum("rs::option") int /* option */ option, double value);

        /// block until new frames are available
        ///
        @CxxMethod
        void wait_for_frames();

        /// check if new frames are available, without blocking
        /// \return  true if new frames are available, false if no new frames have arrived
        @CxxMethod
        boolean poll_for_frames();

        /// retrieve the time at which the latest frame on a stream was captured
        /// \param[in] stream  the stream whose latest frame we are interested in
        /// \return            the timestamp of the frame, in milliseconds since the device was started
        @CxxMethod(isConst = true)
        int get_frame_timestamp(@CxxEnum("rs::stream") int /* stream */ stream);

        /// retrieve the contents of the latest frame on a stream
        /// \param[in] stream  the stream whose latest frame we are interested in
        /// \return            the pointer to the start of the frame data
        @CxxMethod(isConst = true)
        ConstVoidPtr get_frame_data(@CxxEnum("rs::stream") int /* stream */ stream);
    }

    @CxxFunction
    public static native ConstBytePtr rs_stream_to_string(@CxxEnum("rs_stream") int /* stream */ stream);

    @CxxFunction
    public static native ConstBytePtr rs_format_to_string(@CxxEnum("rs_format") int /* format */ format);

    @CxxFunction
    public static native ConstBytePtr rs_preset_to_string(@CxxEnum("rs_preset") int /* preset */ preset);

    @CxxFunction
    public static native ConstBytePtr rs_distortion_to_string(@CxxEnum("rs_distortion") int /* distortion */ distortion);

    @CxxFunction
    public static native ConstBytePtr rs_option_to_string(@CxxEnum("rs_option") int /* option */ option);

    public enum log_severity {
        /**
         * Detailed information about ordinary operations
         */
        debug(0),
        /**
         * Terse information about ordinary operations
         */
        info(1),
        /**
         * Indication of possible failure
         */
        warn(2),
        /**
         * Indication of definite failure
         */
        error(3),
        /**
         * Indication of unrecoverable failure
         */
        fatal(4),
        /**
         * No logging will occur
         */
        none(5),
        //
        ;

        public final int value;

        log_severity(int value) {
            this.value = value;
        }
    }

    @CxxFunction("rs::log_to_console")
    public static native void log_to_console(@CxxEnum("rs::log_severity") int /* log_severity */ min_severity);

    @CxxFunction("rs::log_to_file")
    public static native void log_to_file(@CxxEnum("rs::log_severity") int /* log_severity */ min_severity, ConstBytePtr file_path);
}
